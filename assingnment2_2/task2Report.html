<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aunt's Namesday Seating Scheme</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        h1 {
            color: #333;
        }
        p {
            color: #555;
            margin-bottom: 10px;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>

<h1>Report: Aunt's Namesday Seating Scheme</h1>

<p><strong>Introduction:</strong> Aunt Petunia, our dear relative, has joyfully organized her namesday celebration, inviting friends and family. However, she is cognizant of certain strained relationships among her guests. To maintain harmony and ensure a pleasant atmosphere, Aunt Petunia desires to separate individuals who harbor animosities toward one another. Thus, she seeks assistance in arranging the seating, tasking us, her beloved computer genius, with devising a seating plan. Our objective is to employ a non-recursive Depth-First Search (DFS) algorithm to fulfill Aunt Petunia's wishes and ensure a convivial gathering.</p>

<p><strong>Approach:</strong> The problem presents itself as a graph theory challenge, wherein guests are represented as nodes, and dislikes between guests form the edges of the graph. Our aim is to partition the guests into two tables such that individuals with mutual aversions are seated apart. To accomplish this, we utilize a non-recursive DFS algorithm to determine whether the graph is bipartite. A bipartite graph is one that can be split into two disjoint sets, with no edges existing between nodes within the same set.</p>

<p><strong>Implementation:</strong> Below is the Python implementation of the seating scheme algorithm:</p>

<pre>
<code>
def is_bipartite(graph):
    color = {}
    stack = []

    for node in graph:
        if node not in color:
            stack.append((node, 0))
            while stack:
                current, c = stack.pop()
                if current in color:
                    if color[current] != c:
                        return False, {}
                else:
                    color[current] = c
                    for neighbor in graph[current]:
                        stack.append((neighbor, 1 - c))

    return True, color


def seating_scheme(guests, dislikes):
    graph = {guest: [] for guest in guests}
    for guest1, guest2 in dislikes:
        graph[guest1].append(guest2)
        graph[guest2].append(guest1)

    is_bipart, coloring = is_bipartite(graph)

    if not is_bipart:
        return "Невозможно рассадить гостей за два стола."

    table1 = [guest for guest in coloring if coloring[guest] == 0]
    table2 = [guest for guest in coloring if coloring[guest] == 1]

    return table1, table2


# Example 1
guests = ["Анна", "Борис", "Виктор"]
dislikes = [("Анна", "Борис"), ("Анна", "Виктор"), ("Борис", "Виктор")]

res = seating_scheme(guests, dislikes)
print("Example 1 seating arrangement:", res)

# Example 2
guests = ["Анна", "Борис", "Виктор", "Глеб"]
dislikes = [("Анна", "Борис"), ("Анна", "Виктор"), ("Борис", "Глеб"), ("Виктор", "Глеб")]

res = seating_scheme(guests, dislikes)
print("Example 2 seating arrangement:", res)
</code>
</pre>

<p><strong>Results:</strong></p>
<ol>
    <li>For the first scenario with guests ["Анна", "Борис", "Виктор"] and dislikes [("Анна", "Борис"), ("Анна", "Виктор"), ("Борис", "Виктор")], the seating scheme divides guests into two tables: Table 1: ["Анна"], Table 2: ["Борис", "Виктор"]. This arrangement ensures that guests who dislike each other are seated separately.</li>
    <li>For the second scenario with guests ["Анна", "Борис", "Виктор", "Глеб"] and dislikes [("Анна", "Борис"), ("Анна", "Виктор"), ("Борис", "Глеб"), ("Виктор", "Глеб")], the seating scheme again divides guests into two tables: Table 1: ["Анна", "Глеб"], Table 2: ["Борис", "Виктор"]. This arrangement respects the animosities among the guests.</li>
</ol>

<p><strong>Conclusion:</strong> The implemented algorithm effectively addresses Aunt Petunia's concerns by organizing the seating arrangements in a manner that minimizes potential conflicts among guests. By leveraging a non-recursive DFS algorithm, we efficiently determine the bipartiteness of the graph and devise a logical seating scheme. This ensures Aunt Petunia's namesday celebration is a delightful and enjoyable occasion for all attendees.</p>

</body>
</html>
