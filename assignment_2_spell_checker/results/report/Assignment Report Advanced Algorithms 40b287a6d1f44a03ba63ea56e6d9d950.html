<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Assignment Report: Advanced Algorithms</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="40b287a6-d1f4-4a03-ba63-ea56e6d9d950" class="page sans"><header><h1 class="page-title">Assignment Report: Advanced Algorithms</h1><p class="page-description"></p></header><div class="page-body"><h2 id="28ab8071-ac07-4335-8484-0900dbde236f" class="">Introduction</h2><p id="52d62fbf-73e6-4d44-89c2-e71422525985" class="">The objective of this assignment is to explore and implement various data structures and algorithms for two distinct problems. The first part, &quot;Me Spell Rite,&quot; involves developing a spell checker using multiple approaches and comparing their performance. The second part, &quot;Triwizard Tournament,&quot; requires predicting the winner of a race in a labyrinth using the Breadth-First Search (BFS) algorithm. This report will cover the detailed implementation of each solution, a comparative analysis of the different approaches, and a summary of the findings along with recommendations for future improvements.</p><h2 id="b474de6f-d0f4-4415-929d-534a54897b14" class="">Part One: &quot;Me Spell Rite&quot;</h2><h3 id="d9835047-f266-45d6-a553-3ba44e19734e" class="">Description of the Solution</h3><h3 id="17d3a9fd-de0b-4c15-8d45-24a5915a4666" class="">Naive (Linear List) Approach</h3><p id="53ae7611-153d-443e-81f7-b6c1cab9b2e6" class="">The naive approach involves storing the dictionary words in a simple list. For spell checking, each word in the text is checked against this list using a linear search. This method is straightforward but inefficient, especially for large datasets.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3e714068-4bd7-4d3e-95fa-2e6de620b39a" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">class NaiveDictionary:
    def __init__(self):
        self.words = []

    def load(self, dictionary_file):
        with open(dictionary_file, &#x27;r&#x27;) as file:
            self.words = [line.strip() for line in file]

    def spell_check(self, text_file):
        with open(text_file, &#x27;r&#x27;) as file:
            text = file.read().split()
        misspelled = [word for word in text if word not in self.words]
        return misspelled</code></pre><h3 id="781401aa-6b25-48b0-bc22-454e8af2d0c8" class="">Balanced Binary Search Tree (BBST) Approach</h3><p id="78b2cdc8-0372-4d34-b429-61ef8331d27b" class="">The BBST approach uses a balanced binary search tree to store the dictionary words. In Python, this is implemented using the <code>sortedcontainers</code> library, which maintains a sorted list. This allows for faster search operations compared to the naive approach due to the logarithmic time complexity of binary search.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4b13d350-ce6f-41d9-8542-1736e554966b" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">from sortedcontainers import SortedSet

class BBSTDictionary:
    def __init__(self):
        self.words = SortedSet()

    def load(self, dictionary_file):
        with open(dictionary_file, &#x27;r&#x27;) as file:
            self.words.update(line.strip() for line in file)

    def spell_check(self, text_file):
        with open(text_file, &#x27;r&#x27;) as file:
            text = file.read().split()
        misspelled = [word for word in text if word not in self.words]
        return misspelled</code></pre><h3 id="96ca619e-b486-4089-9122-265804fc0622" class="">Trie Data Structure</h3><p id="660777af-e06d-402b-9b8e-1ab9285c2064" class="">A Trie, or prefix tree, is a specialized tree used to store associative data structures. Each node represents a character of a word, and the path down the tree represents the word itself. This approach is highly efficient for search operations, particularly for prefix-based searches.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d64f68cb-5843-4fc5-9310-2ded1da2b57f" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

class TrieDictionary:
    def __init__(self):
        self.trie = Trie()

    def load(self, dictionary_file):
        with open(dictionary_file, &#x27;r&#x27;) as file:
            for line in file:
                self.trie.insert(line.strip())

    def spell_check(self, text_file):
        with open(text_file, &#x27;r&#x27;) as file:
            text = file.read().split()
        misspelled = [word for word in text if not self.trie.search(word)]
        return misspelled</code></pre><h3 id="4dcfe07c-4da4-41a5-b6c6-9398b370b51c" class="">Hash Map Approach</h3><p id="dfc6c5f3-68cc-4354-b5f4-5e1ef2228b0d" class="">The hash map approach uses Python&#x27;s built-in <code>set</code> to store the dictionary words. This data structure allows for average-case constant time complexity for both insertion and search operations, making it highly efficient for the spell-checking task.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1a04d8c6-19e1-4772-894a-f2546abfc07d" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">class HashMapDictionary:
    def __init__(self):
        self.words = set()

    def load(self, dictionary_file):
        with open(dictionary_file, &#x27;r&#x27;) as file:
            self.words.update(line.strip() for line in file)

    def spell_check(self, text_file):
        with open(text_file, &#x27;r&#x27;) as file:
            text = file.read().split()
        misspelled = [word for word in text if word not in self.words]
        return misspelled</code></pre><h3 id="0280e5fd-c2be-4140-9604-cd5747c0646b" class="">Comparative Analysis</h3><h3 id="12c5d3df-2789-485d-a5b7-affc872e1403" class="">Running Times for Dictionary Building</h3><ul id="c57e2bf4-96ca-470a-9e57-4cb8d48d63ab" class="bulleted-list"><li style="list-style-type:disc"><strong>Naive Dictionary Load:</strong> 0.0102 seconds</li></ul><ul id="17cdbea1-4fd5-4457-bac6-34ab2d96e2c0" class="bulleted-list"><li style="list-style-type:disc"><strong>BBST Dictionary Load:</strong> 0.0436 seconds</li></ul><ul id="dda01eed-ebcf-4e54-81c5-6dcb2250cc7e" class="bulleted-list"><li style="list-style-type:disc"><strong>Trie Dictionary Load:</strong> 0.1837 seconds</li></ul><ul id="f23eb01d-00a2-42e9-8b4d-a36d9bb29507" class="bulleted-list"><li style="list-style-type:disc"><strong>HashMap Dictionary Load:</strong> 0.0248 seconds</li></ul><h3 id="62e3ba0d-c32e-44c8-897d-9b9325e45a0b" class="">Spell-Checking Performance</h3><ul id="39545261-cee2-490d-87d6-e09767b953ac" class="bulleted-list"><li style="list-style-type:disc"><strong>Naive Dictionary Spell Check:</strong> 1.9693 seconds</li></ul><ul id="a70d769d-c8df-4b5d-9216-e6cae0d5ef48" class="bulleted-list"><li style="list-style-type:disc"><strong>BBST Dictionary Spell Check:</strong> 0.0008 seconds</li></ul><ul id="5ee21f88-545f-47ee-8bc3-c44d2c1ce894" class="bulleted-list"><li style="list-style-type:disc"><strong>Trie Dictionary Spell Check:</strong> 0.0018 seconds</li></ul><ul id="b64ff75a-543e-4a68-8b17-34167b74e208" class="bulleted-list"><li style="list-style-type:disc"><strong>HashMap Dictionary Spell Check:</strong> 0.0006 seconds</li></ul><h3 id="caf8941f-c75c-4890-a206-91bb6abbafcc" class="">Results and Graphs</h3><h3 id="a3575073-e259-48b3-b1ce-0b7f6a34d91f" class="">Summary of Results</h3><p id="aa6b39c2-ce45-4490-9284-c7c8308eb726" class="">The table below summarizes the results of the dictionary loading and spell-checking times for each approach:</p><table id="a09af653-2dea-4fa2-a0ae-c1f5a7ca85fd" class="simple-table"><tbody><tr id="65a412fd-1f22-4951-9252-d8224cf896c3"><td id="FtQH" class="">Approach</td><td id="Ggsz" class="">Dictionary Load Time (s)</td><td id="{JC&lt;" class="">Spell Check Time (s)</td></tr><tr id="baf5cb5f-9734-45ba-a3d7-b07698281870"><td id="FtQH" class="">Naive</td><td id="Ggsz" class="">0.0102</td><td id="{JC&lt;" class="">1.9693</td></tr><tr id="cdb94a7b-5be4-4673-94a8-9bbe043d3862"><td id="FtQH" class="">BBST</td><td id="Ggsz" class="">0.0436</td><td id="{JC&lt;" class="">0.0008</td></tr><tr id="5f95bc62-fbf5-4294-a9b5-185bf5d8a112"><td id="FtQH" class="">Trie</td><td id="Ggsz" class="">0.1837</td><td id="{JC&lt;" class="">0.0018</td></tr><tr id="aeb0f667-a27f-457c-8004-e484e64475de"><td id="FtQH" class="">HashMap</td><td id="Ggsz" class="">0.0248</td><td id="{JC&lt;" class="">0.0006</td></tr></tbody></table><h3 id="8dcb760d-84c3-44d8-ba09-0101df328926" class="">Graphs Showing Runtime Performance</h3><p id="aadb1b18-e43a-400d-bc84-1f397655d7e7" class="">Below is a bar chart that visualizes the performance of different approaches for both dictionary loading and spell-checking times:</p><figure id="6ea48334-122e-4d21-ac10-88895d1bee75" class="image"><a href="Assignment%20Report%20Advanced%20Algorithms%2040b287a6d1f44a03ba63ea56e6d9d950/Untitled.png"><img style="width:707.9971313476562px" src="Assignment%20Report%20Advanced%20Algorithms%2040b287a6d1f44a03ba63ea56e6d9d950/Untitled.png"/></a></figure><h3 id="bb2ea218-c490-4e8c-8194-c2879aad3d91" class="">Pros and Cons of Each Approach</h3><ul id="de525ed2-7aa1-4ca8-b5ec-73cd7c3b935d" class="bulleted-list"><li style="list-style-type:disc"><strong>Naive Approach:</strong><ul id="edf0ad95-e930-47f8-9e52-3cab8200e508" class="bulleted-list"><li style="list-style-type:circle"><strong>Pros:</strong> Simple to implement.</li></ul><ul id="cd265b4f-428e-49db-8f9b-cc5321555ecc" class="bulleted-list"><li style="list-style-type:circle"><strong>Cons:</strong> Slow for large datasets due to linear search.</li></ul></li></ul><ul id="7c81ce7d-924d-441b-8e5b-b4ade6bdec1c" class="bulleted-list"><li style="list-style-type:disc"><strong>BBST Approach:</strong><ul id="5a840e84-c872-43d3-b856-42f22d419ec2" class="bulleted-list"><li style="list-style-type:circle"><strong>Pros:</strong> Faster search times due to binary search.</li></ul><ul id="da43368d-c51a-4e9f-8835-a24583cc4d63" class="bulleted-list"><li style="list-style-type:circle"><strong>Cons:</strong> Slightly more complex to implement and higher load time compared to naive approach.</li></ul></li></ul><ul id="997d7960-b441-4b15-bb87-f668144ce43b" class="bulleted-list"><li style="list-style-type:disc"><strong>Trie Approach:</strong><ul id="69117522-7eb7-4d28-8b76-d4f588cd79c1" class="bulleted-list"><li style="list-style-type:circle"><strong>Pros:</strong> Highly efficient for prefix searches and moderate search times.</li></ul><ul id="90327e82-bd0a-4396-a2cb-3be15700dd97" class="bulleted-list"><li style="list-style-type:circle"><strong>Cons:</strong> Higher memory usage and slower load times.</li></ul></li></ul><ul id="33b5698d-be49-437b-83aa-49186b0283bf" class="bulleted-list"><li style="list-style-type:disc"><strong>Hash Map Approach:</strong><ul id="56a21307-8e19-4f8b-be25-141dec4448e8" class="bulleted-list"><li style="list-style-type:circle"><strong>Pros:</strong> Fastest search times due to constant time complexity.</li></ul><ul id="87a439b7-77a9-4047-9cfe-a10208cf861f" class="bulleted-list"><li style="list-style-type:circle"><strong>Cons:</strong> Slightly higher load time compared to naive approach.</li></ul></li></ul><h2 id="7ab30226-2a9e-4fd5-9dd7-4aa8fa72a232" class="">Part Two: &quot;Triwizard Tournament&quot;</h2><h3 id="43197a58-ef72-4e46-b0c9-5e378e28f511" class="">Description of the Solution</h3><h3 id="029711f9-b6a7-4457-92ad-625c35e3131b" class="">Labyrinth Map Representation</h3><p id="01412b1c-6092-45ba-97fd-601bffbcf9ba" class="">The labyrinth is represented as an adjacency list where each node (corridor) has a list of its neighboring nodes. For example:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="21bc2b83-48dd-4ed4-bf6e-89242bd1622c" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">labyrinth = {
    &#x27;A&#x27;: [&#x27;B&#x27;, &#x27;C&#x27;],
    &#x27;B&#x27;: [&#x27;D&#x27;, &#x27;E&#x27;],
    &#x27;C&#x27;: [&#x27;F&#x27;],
    &#x27;D&#x27;: [],
    &#x27;E&#x27;: [],
    &#x27;F&#x27;: [&#x27;E&#x27;]
}
</code></pre><h3 id="f566e30c-7e28-472c-b02d-0e5853f48b35" class="">Initial Positions and Speeds of the Wizards</h3><p id="0b85d95a-5ddf-4600-85f5-ee5284d6fb76" class="">The initial positions of the wizards and their speeds are defined as follows:</p><ul id="9e2d5298-a8fb-425b-b1af-15c05735034b" class="bulleted-list"><li style="list-style-type:disc"><strong>Initial Positions:</strong> [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</li></ul><ul id="80074afc-fb7f-4cea-a816-b5bd883788d2" class="bulleted-list"><li style="list-style-type:disc"><strong>Speeds:</strong> [1, 2, 1.5] (in corridors per minute)</li></ul><h3 id="2746aa01-faf0-4b92-a514-f6084c76671e" class="">Breadth-First Search (BFS) Algorithm</h3><p id="2162be25-8018-4218-b209-2af360130e6c" class="">The BFS algorithm is used to find the shortest path from each wizard&#x27;s starting position to the exit. BFS explores all neighbors at the present depth prior to moving on to nodes at the next depth level, ensuring the shortest path in an unweighted graph.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="826387b9-da7f-4a05-af8b-297956814263" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">from collections import deque

class BFS:
    @staticmethod
    def find_shortest_path(labyrinth, start, end):
        queue = deque([start])
        visited = {start}
        distance = {start: 0}

        while queue:
            current = queue.popleft()

            if current == end:
                return distance[current]

            for neighbor in labyrinth.get(current, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
                    distance[neighbor] = distance[current] + 1

        return float(&#x27;inf&#x27;)
</code></pre><h3 id="f84b15ce-c272-49ff-9895-e4e0246004ab" class="">Analysis and Findings</h3><h3 id="c85c078b-6ffe-4d07-86c0-7c0045382012" class="">Application of</h3><p id="8a145bdf-60b1-449f-952a-64e07099982d" class="">BFS</p><p id="b36907ce-43ec-4e68-8c17-deec2feb2b8b" class="">The BFS algorithm was applied to find the shortest path from each wizard&#x27;s starting position to the exit. The time taken for each wizard to reach the exit was calculated based on their speed and the length of the shortest path.</p><h3 id="938c7250-1d91-4ac0-8000-8370742df1bc" class="">Prediction Results</h3><p id="50b96d0d-ef31-41ac-90e9-8b32d0ab8b16" class="">The wizard who reaches the exit first is wizard B, given their higher speed and the layout of the labyrinth.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f2413a8b-dbc2-49cf-9f93-9ec255793a0f" class="code"><code class="language-Python" style="white-space:pre-wrap;word-break:break-all">class WizardRace:
    def __init__(self, labyrinth, exit_position):
        self.labyrinth = labyrinth
        self.exit_position = exit_position

    def predict_winner(self, wizards, speeds):
        times = []

        for wizard, speed in zip(wizards, speeds):
            time_to_exit = BFS.find_shortest_path(self.labyrinth, wizard, self.exit_position) / speed
            times.append((time_to_exit, wizard))

        return min(times)[1]

# Example usage
labyrinth = {
    &#x27;A&#x27;: [&#x27;B&#x27;, &#x27;C&#x27;],
    &#x27;B&#x27;: [&#x27;D&#x27;, &#x27;E&#x27;],
    &#x27;C&#x27;: [&#x27;F&#x27;],
    &#x27;D&#x27;: [],
    &#x27;E&#x27;: [],
    &#x27;F&#x27;: [&#x27;E&#x27;]
}
wizards = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]
speeds = [1, 2, 1.5]
race = WizardRace(labyrinth, &#x27;E&#x27;)
winner = race.predict_winner(wizards, speeds)
print(f&quot;The wizard who will reach the exit first is: {winner}&quot;)
</code></pre><h3 id="9cf4facc-f40a-41d1-bd21-451e64a7731f" class="">Assumptions and Impact</h3><ul id="72bea603-25f0-4da4-80be-48b76c95615c" class="bulleted-list"><li style="list-style-type:disc">The wizards move at a constant speed through the corridors.</li></ul><ul id="77c43e8b-6363-40e7-98cc-9015a4b15212" class="bulleted-list"><li style="list-style-type:disc">The labyrinth&#x27;s layout is fixed and does not change during the race.</li></ul><h2 id="53ceedb7-6b62-4392-935b-7b1d62ad9672" class="">Conclusion</h2><h3 id="a3a7919b-d4fd-4749-b502-f06e9e4cb68c" class="">Summary of Findings</h3><ul id="330860b0-f374-453f-a4d0-dd72d49e6807" class="bulleted-list"><li style="list-style-type:disc"><strong>Spell Checker:</strong> The Hash Map approach was the fastest for both loading and spell checking. The Trie approach, while efficient for searches, had the highest load time. The Naive approach was the slowest for spell checking.</li></ul><ul id="dd8e199e-ac13-4bdf-b6bb-88a7c8fbb77c" class="bulleted-list"><li style="list-style-type:disc"><strong>Labyrinth Race:</strong> Wizard B was predicted to reach the exit first due to their higher speed and favorable starting position.</li></ul><h3 id="11c20ad2-2e85-4326-8931-2211bc7eb035" class="">Recommendations</h3><ul id="853cd214-800c-4488-98a5-ddd7f6421a50" class="bulleted-list"><li style="list-style-type:disc">For large datasets, the Hash Map approach is recommended for spell checking due to its fast search times.</li></ul><ul id="0ec784e2-cadb-4ded-a30e-1c4fc1eb6022" class="bulleted-list"><li style="list-style-type:disc">Further optimization could be explored for the Trie approach to reduce load times.</li></ul><ul id="b731222f-0cc8-4054-b8a0-1d54ab8d0669" class="bulleted-list"><li style="list-style-type:disc">For the labyrinth problem, additional factors such as dynamic obstacles or varying speeds could be considered for more complex scenarios.</li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>